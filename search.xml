<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C# 基础语法练习-飞行棋游戏]]></title>
    <url>%2F2017%2F05%2F16%2FC-%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0-%E9%A3%9E%E8%A1%8C%E6%A3%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[玩法描述 先后输入两个玩家的姓名 打印出棋盘，开始游戏 双方掷骰子，按掷得的点数向前走相应的步数 走完后按棋子落在棋盘上的位置，做出相应的动作，如下 □ 什么都不发生 ◎ 幸运轮盘，与对方交换位置，或轰炸对方使其后退 6 格 ☆ 地雷，玩家后退 6 格 ▲ 暂停，玩家跳过下一回合 卐 时空隧道，玩家前进 10 格 先走出棋盘的玩家获得胜利 思路可通过数组来存储棋盘和玩家，通过枚举来存储棋盘上各个位置的符号(特殊符号不可作为枚举值)，轮流掷骰子、改变棋子位置等步骤通过 while 循环实现，跳出条件是，其中一方走出了棋盘。 代码除主函数外，一共分为 6 个函数，各个函数的作用在文档注释中有解释。12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 欢迎界面或结束界面/// &lt;/summary&gt;/// &lt;param name="printString"&gt;要打印的字符串&lt;/param&gt;static void StartOrFinish(string printString)/// &lt;summary&gt;/// 设置玩家/// &lt;/summary&gt;static void SetPlayer()/// &lt;summary&gt;/// 玩法说明/// &lt;/summary&gt;static void HowToPlay()/// &lt;summary&gt;/// 初始化地图/// &lt;/summary&gt;static void InitMaps()/// &lt;summary&gt;/// 画地图/// &lt;/summary&gt;static void DrawMaps()/// &lt;summary&gt;/// 判断要画的符号/// &lt;/summary&gt;/// &lt;param name="i"&gt;地图坐标&lt;/param&gt;/// &lt;returns&gt;要画的符号&lt;/returns&gt;static string JudgeDrawString(int i)/// &lt;summary&gt;/// 游戏流程/// &lt;/summary&gt;/// &lt;param name="i"&gt;玩家下标&lt;/param&gt;static void PlayGame(int i)/// &lt;summary&gt;/// 检查玩家是否处于地图内/// &lt;/summary&gt;static void SecurityCheck() 另外有四个全局变量用于存储游戏中的数据。 12345678910//地图static readonly int[] Maps = new int[100];//玩家的名称static readonly string[] PlayerName = new string[2];//玩家在棋盘上的位置static readonly int[] PlayerPos = new int[2];//地图数组中的数值所代表的符号static readonly string[] DrawHelper = &#123; "□", "◎", "☆", "▲", "卐" &#125;;//玩家是否踩到暂停static readonly bool[] Pause = new bool[2]; SetPlayer 函数中，使用循环判断玩家输入的名称，防止其值为空。 1234567Console.WriteLine("请输入玩家 A 的姓名");PlayerName[0] = Console.ReadLine();while (String.IsNullOrEmpty(PlayerName[0]))&#123; Console.WriteLine("输入错误，请重新输入"); PlayerName[0] = Console.ReadLine();&#125; 若输入为空，则进入循环，直到输入不为空，跳出循环。 InitMaps 函数中，先定义特殊符号在地图数组中的下标的数组，然后使用该数组循环用于给空地图赋值。例如，定义幸运轮盘下标的数组，并使用循环赋值。 12345int[] luckyturn = &#123; 6, 23, 40, 55, 69, 83 &#125;;foreach (int chess in luckyturn)&#123; Maps[chess] = 1;&#125; 初始化地图数组后，在JudgeDrawString 函数中，通过传入地图下标来确定要画的符号，除特殊符号外还要考虑特殊情况，也就是玩家 A 或 B 是否在该坐标上。 1234567891011121314string symbol;Console.ForegroundColor = ConsoleColor.Blue;if (i.Equals(PlayerPos[0]) &amp;&amp; i.Equals(PlayerPos[1])) symbol = "AB";else if (i.Equals(PlayerPos[0])) symbol = "Ａ";else if (i.Equals(PlayerPos[1])) symbol = "Ｂ";else&#123; Console.ForegroundColor = ConsoleColor.White; symbol = DrawHelper[Maps[i]];&#125;return symbol; 然后在 DrawMaps 数组中循环调用 JudgeDrawString 便可画出地图。 在 PlayGame 函数中生成随机数，然后根据传入的玩家下标（0 或 1）使玩家做出相应的动作，并使用 switch 语法判断玩家前进后踩到棋盘指定位置的相应动作。有时有需要改变对方玩家位置的情况，例如 轰炸对方使其后退 6 格，可以使用 1 - i 得到对方玩家的下标。 12345678Random random = new Random();int step = random.Next(1, 7);PlayerPos[i] += step;Console.WriteLine("玩家 &#123;0&#125; 掷到了 &#123;1&#125; ，踩到了&#123;2&#125;", PlayerName[i], step, DrawHelper[Maps[PlayerPos[i]]]);switch(Maps[PlayerPos[i]])&#123; //...&#125; 另外有一点值得注意，SecurityCheck 函数在每次玩家坐标发生变化后执行一次，用来防止玩家跑出地图的情况发生，除此之外还为了防止数组越界，如果不执行安全检查，则当玩家坐标在 [0, 99] 之外时，Maps[PlayerPos[i]] 就会发生数组越界。 检查数组越界的一种情况，其余情况与之类似。 123if (PlayerPos[0] &gt; 99) &#123; PlayerPos[0] = 99;&#125; 在主函数中，完成打印欢迎界面、设置玩家、玩法说明等操作后，使用循环调用 PlayGame 函数，并传入当前玩家的下标，当 !(PlayerPos[0] &lt; 99 &amp;&amp; PlayerPos[1] &lt; 99) ，即任意玩家走到地图最后时，循环跳出，游戏结束。1234567891011int i = 0;while (PlayerPos[0] &lt; 99 &amp;&amp; PlayerPos[1] &lt; 99)&#123; if (Pause[i]) &#123; Pause[i] = false; i = 1 - i; &#125; PlayGame(i); i = 1 - i;&#125; 在 PlayGame 中的 switch 语句中，有一种玩家踩到暂停的情况，这时会将该玩家对应的 Pause 数组中的值改为 false。 1234case 3: Console.WriteLine("玩家 &#123;0&#125; 暂停一回合", PlayerName[i]); Pause[i] = true; break; 而主函数中的 while 语句每次执行 PlayGame 前会判断，如果当前玩家被暂停，那么先将数组中的值改为 false (防止永久暂停)，然后将 i 改变为对方玩家对应的值传入函数，就完成了玩家暂停一回合的效果。 123456if (Pause[i])&#123; Pause[i] = false; i = 1 - i;&#125;PlayGame(i);]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第七章-调试和错误处理]]></title>
    <url>%2F2017%2F05%2F10%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%B0%83%E8%AF%95%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[编写应用程序时，有时会犯一些简单的语法错误，当错误发生时 VS 就会提示错误。但有时一些错误只有在运行时才能被发现，此时就可以依靠 VS 的调试功能。另外 C# 中的错误处理技术可以对可能发生错误的地方采取预防措施。 Visual Studio 中的调试在 VS 中运行应用程序分为调试模式(F5)和非调试模式(Ctrl + F5)，非调试模式仅仅是运行编写好的代码，而调试模式不仅运行代码，还包含了应用程序的符号信息，这使得我们可以执行很多操作。 向 IDE 输出调试信息 在执行应用程序期间查看作用域内变量的值 暂停程序和重启程序 在代码的某个位置自动暂停应用程序 一次执行程序中的一行代码 在应用程序的执行期间监视变量的内容变化 在运行期间修改变量的内容 测试函数的调用 调试模式对应调试配置，非调试模式对应发布配置。发布配置不能做以上操作，但是发布版本运行速度较快，容量较小。所以在应用程序完成开发时应给用户提供发布版本。 非中断(正常)模式下的调试Console.WriteLine() 函数可以输出信息，利用它可以进行简单的调试，例如输出变量，或在指定位置输出信息以确定程序执行是否按预期执行。 但是打印在控制台上会比较混乱，而且其他类型的程序可能没有控制台，例如桌面应用程序。这事就可以利用其他函数将信息输出在输出窗口。 若找不到输出窗口，可在 菜单 | 视图 | 输出 打开。 Debug.WriteLine() Trace.WriteLine() 以上两个命令会把信息输出在输出窗口上，Debug.WriteLine() 仅在调试模式下运行，在发布时，该命令会消失。 Trace.WriteLine() 还可用于发布程序。 这两个命令不像 Console.WriteLine() 一样可以使用 {x} 的形式插入变量值，只能使用 + 进行拼接。另外它们还可以接收第二个字符串参数，作用是显示输出的类别。 还有两种和 Console.Write() 对应的函数 Debug.Write() Trace.Write() 还有下列函数 Debug.WriteLineIf() Trace.WriteLineIf() Debug.WriteIf() Trace.WriteIf() 这些函数比之前的函数增加了一个必选参数，且该必选参数需要放在参数列表的最前面。这个参数的值为布尔值，只有为 true 时才执行该函数。通常我们传为一个表达式，当表达式为 true 时，执行该函数。 跟踪点也可以把信息输出到输出窗口中，这时 VS 的功能而非 C# 的功能，他可以在不修改代码的情况下输出调试信息。 再要插入跟踪点的行上右击选择 断点 | 跟踪点 ，可以在对话框中键入要输入的消息，变量使用花括号括起来。创建完成后该行的左侧便会显示一个菱形。 跟踪点属于断点的一种，跟踪点比较之前介绍的函数可以键入一些关键字输出跟上下文有关的其他信息。 点击菜单中的 调试 | 窗口 | 断点，可方便地管理跟踪点。 跟踪点类似 Debug.WriteLine() ，并不存在于发布版本中。 但是使用跟踪点的关键字可以方便的完成 Debug 和 Trace 难以完成的功能。 中断模式下的调试进入中断模式进入中断模式的最简单的方式就是在应用程序执行时，点击暂停按钮。但是这不能停在指定的位置，所以通常情况下，最好使用断点。 断点可配置为以下功能 在遇到断点时，立即进入中断模式 在遇到断点时，如果布尔表达式为 true ，就进入中断模式 遇到某断点一定次数后，进入中断模式 在遇到断点时，如果自从上次遇到断点以来变量的值发生了变化，进入中断模式 把文本输出到输出窗口中，或执行一个宏。 断点也不存在于发布版本。 点击某行代码的左侧，出现红色原点，即可添加一个简单的断点。即是遇到断点立即进入中断模式功能的断点。 断点窗口也可以方便的管理断点，例如禁用、删除、编辑属性和加标签等，加上标签即可分组管理断点。 在断点窗口右击断点，其中的条件和命中次数可配置以上功能。另外断点还有更多的属性可配置。 有附加属性的断点与普通断点的显示方式稍有不同，普通断点仅显示一个圆点，而有附加属性的断点会在其中有一个加号。 使用 Debug.Assert() 或 Trace.Assert() 也可以进入中断模式，这两个函数带 3 个参数，第一个参数为布尔值，当为 false 时触发判定语句，第二和第三个参数均为字符串，分别为显示到对话框和输出窗口的消息。 该对话框有三个选项，Abort 为终止程序，Retry 为进入中断模式，Ignore 为忽略。 监视变量内容在中断模式下，光标停留在变量名上，即可看到该变量的内容。 在程序运行时，IDE 窗口会变化，其中增加了几个窗口，自动窗口、局部变量和监视，这些窗口可以方便的在运行时监视变量，甚至可以不修改代码的情况下改变变量的值。 自动窗口：当前和前面语句使用的变量 局部变量：在作用域内所有的变量 监视：可定制的变量，可在名称列键入变量名称即可监视 另外选中变量或表达式，右击选择快速监视，也可方便的显示变量信息。 单步执行代码单步执行代码在中断模式下，可以控制应用程序执行的步骤。 F11: 逐条执行语句 F10: 逐过程执行语句，不会进入嵌套的代码块，包括函数。 Shiift+F11 或 F5: 跳出中断 命令窗口和即时窗口命令窗口可以手动执行 VS 操作。即时窗口可以执行与当前正在执行的源代码不同的额外代码，以及算术表达式。 例如正在执行的源代码中有一个长度为 10 数组 arr，其下标为 3 的值为 10，在即时窗口中键入 arr[3] * 10 即可得到结果 100 。 调用堆栈窗口该窗口描述了程序是如何执行到当前位置的，它显示了当前函数，调用它的函数以及调用该函数的函数。 错误处理之前讲述了如何查找应用程序的错误以便改正，但是有的错误是我们无法掌控的，例如将用户的输入转换为 double 类型，我们无法控制用户的输入，但是我们可以预先考虑到这种情况，并用一些方式应对这些错误。 try…catch…finallyC# 语言包含结构化异常处理，用 3 个关键字可以标记出能处理异常的代码和指令，如果发生异常，就是用这些指令处理异常。结构如下 1234567try &#123; &#125; catch(&lt;exceptionType&gt; e) &#123;&#125; finally &#123;&#125; 可以只有 try 和 finally，或者有一个 try 和 多个 catch，如果有一个 catch，finally 就是可选的，否则就是必须的。 try: 包含抛出异常的代码。 catch: 包含抛出异常时要执行的代码，catch 可以使用 &#60;exceptionType&#62; ，设置只响应特定类型的异常。也可以省略，让其响应所有异常。 finally: 包含始终会执行的代码，如果没有异常，则在 try 之后执行，如果处理了异常，则在 catch 后执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static string[] eTypes = &#123; "none", "simple", "index", "nested index" &#125;;static void Main(string[] args)&#123; foreach (string eType in eTypes) &#123; try &#123; Console.WriteLine("Main() try block reached."); Console.WriteLine("ThrowException(\"&#123;0&#125;\") called.", eType); ThrowException(eType); Console.WriteLine("Main() try block continues."); &#125; catch (System.IndexOutOfRangeException e) &#123; Console.WriteLine("Main() System.IndexOutOfRangeException catch block reached. Message:\n\"&#123;0&#125;\"", e.Message); &#125; catch &#123; Console.WriteLine("Main() general catch block reached."); &#125; finally &#123; Console.WriteLine("Main() finally block reached."); &#125; Console.WriteLine(); &#125; Console.ReadKey();&#125;static void ThrowException(string exceptionType) &#123; Console.WriteLine("ThrowException (\"&#123;0&#125;\") reached.", exceptionType); switch (exceptionType) &#123; case "none": Console.WriteLine("Not throwing an exception."); break; case "simple": Console.WriteLine("Throwing System.Exception."); throw new Exception(); case "index": Console.WriteLine("Throwing System.IndexOutOfRangeException."); eTypes[4] = "error"; break; case "nested index": try &#123; Console.WriteLine("ThrowException (\"nested index\") try block reached."); Console.WriteLine("ThrowException(\"index\") called."); ThrowException("index"); &#125; catch &#123; Console.WriteLine("ThrowException(\"nested index\") general catch block reached."); &#125; finally &#123; Console.WriteLine("ThrowException(\"nested index\") finally block reached."); &#125; break; &#125;&#125; throw 关键字生成一个异常，需要为这个关键字提供新初始化的异常作为其参数，抛出一个新的异常，这里使用名称空间 System 中的另一个异常 System.Exception 。 这里注意，throw 可以结束 case 的执行。 当 &quot;simple&quot; case 块抛出异常时，回到 Main 函数中的 catch 中处理异常，第一个 catch 不匹配，所以转而去执行第二个一般 catch 块，最后执行 finally 块。 &quot;index&quot; case 块中访问一个不存在的数组元素，会抛出 System.IndexOutOfRangeException 异常，Main 函数中有对应的 catch 块，所以会执行对应的 catch 块，执行完毕会跳出 catch 的执行，所以不会去执行第二个一般 catch 块，转而去执行 finally 。 &quot;nested index&quot; case 块中嵌套调用了 ThrowException 函数，进入 &quot;index&quot; case 块中，访问不存在的数组元素，抛出 System.IndexOutOfRangeException 异常，但是 &quot;nested index&quot; case 块中没有对应的 catch 块，所以会执行其中的一般 catch 块。 列出和配置异常点击菜单中的 调试 | 异常 打开对话框，该对话框按照类别和 .NET 库名称空间列出异常。右边的 引发 列，意思是即使是对于已处理的异常，也会进入调试器，第二个选项可以忽略未处理的异常。多数情况下，使用默认配置就足够了。 异常处理的注意事项注意，必须在更一般的异常捕获之前为比较特殊的异常提供 catch 块，如果顺序错误，则会编译失败。 还要注意可以在 catch 块中抛出异常，如在上个示例中，如果在 ThrowException 中使用 throw 抛出异常，那么就由它的上一级，也就是 Main 函数接收异常并处理。 练习Q: “使用Trace.WriteLine()要优于Debug.WriteLine()，因为调试版本仅能用于调试程序。”这个观点正确吗？为什么？ A: 不正确，因为我们通常希望在调试版本下去调试程序。 Q: 为一个简单的应用程序编写代码，其中包含一个循环，该循环在运行 5000 次后产生一个错误。使用断点在第 5000 次循环出现错误前进入中断模式(注意产生错误的一种简单方式是试图访问一个不存在的数组元素，例如在一个有100 个元素的数组中，访问 myArray[1000])。 A: 12345678static void Main(string[] args)&#123; int[] array = new int[5000]; for (int i = 0; i &lt; 5001; i++) &#123; array[i] = i; &#125; Console.ReadKey();&#125; 单击 array[i] = i; 所在的行的左侧产生一个断点，在断点窗口，右击刚刚产生的断点设置，设置命中次数为：中断，条件式命中次数等于 5000 ，或者设置条件为 i==5000 为 true 时。 Q: 只有在不执行 catch 块的情况下，才执行 finally 代码块”，对吗？ A: 错，finally 块，在任何情况下都会执行。 Q: 下面定义了一个枚举数据类型 orientation。编写一个应用程序，使用结构化异常处理(SEH)把 byte 类型的变量安全地强制转换为 orientation 类型变量。注意，可以使用 checked 关键字强制抛出异常，下面是一个示例。可以在应用程序中使用这段代码： 12345678enum Orientation : byte&#123; North = 1, South = 2, East = 3, West = 4&#125;myDirection = checked((Orientation)myByte); A: 12345678910111213141516171819202122enum Orientation : byte&#123; North = 1, South = 2, East = 3, West = 4&#125;static void Main(string[] args)&#123; try &#123; byte myByte = 100; Orientation myDirection; myDirection = checked((Orientation)myByte); throw new ArgumentOutOfRangeException("myByte", myByte,"数值必须在 1-4 之间"); &#125; catch (ArgumentOutOfRangeException e) &#123; Console.WriteLine(e.Message); &#125; Console.ReadKey();&#125;]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第六章-函数]]></title>
    <url>%2F2017%2F05%2F07%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有时一串相同的(或几乎相同的)代码，要在一个程序中的不同位置执行多次，简单的办法是在每次要执行的地方都写上相同的代码，但是这么做不仅使程序显的不干净、累赘，而且想要修改该段代码的时候，需要修改多处，这么做很容易出现失误。那么这时候我们就可以使用函数来解决这个问题。 例如我们需要一段代码来获取数组最大值，又需要在多个地方使用，这时就需要使用函数来编写这段代码，而在需要使用这段代码的地方，只需要简单的语句调用这个函数就可以了。 我们使用这段代码的目的是获取数组最大值，那么必然这个函数会有一个返回值供调用者去使用。而我们每次需要求最大值的数组可能也不相同，这就要求在函数内部，该数组是可变的，这时就要求该函数可以让我们传入参数。 即使不需要重用的代码段也可以写成函数的形式，因为当我们调用函数时，只需要调用该函数的名字(也可能会传入一些参数)，那么我们可以给函数一个可描述该函数功能的简短的名称，就可以达到缩短应用程序主体的目的，同时代码的可读性也更好，因为阅读者可能并不需要关心这段代码是怎么完成一个功能，而只要知道它完成了什么功能就够了。 定义和使用函数定义一个简单的函数并调用它 12345678static void Write() &#123; Console.WritreLine("Text output from function");&#125;static void Main(string[] args) &#123; Write(); Console.ReadKey();&#125; Write 函数和 Main 函数的很类似，因为它们都是函数，而 Main 函数是控制台应用程序的入口函数。 static 关键字将在以后的笔记中解释。 void 关键字表示该函数没有返回值。 调用代码只需要 函数名 + 括号的形式就可以了，当执行到此，就会去寻找函数中的具体代码。 返回值1234567891011121314static string GetMyString() &#123; string myString = "随机数小于或等于 0.5"; Random random = new Random(); double myDoubleVal = random.NextDouble(); if (myDoubleVal &gt; 0.5) &#123; myString = "随机数大于 0.5"; &#125; return myString;&#125;static void Main(string[] args) &#123; Console.WriteLine(GetMyString()); Console.ReadKey();&#125; 一个有返回值的函数，要在函数名前指定该返回值的类型，可以是任何类型如 GetMyString 函数返回一个 string 类型的值。并且需要且必须使用 return 语句返回该类型的值。 return 语句可以在函数的任何位置，但必须保证在执行该函数时会执行到 return 语句。 当执行到 return 语句时，函数会立即终止，若接下来还有语句，将不再执行。 返回值为 void 的函数，也可以在其中使用 return 语句，但不能在 return 后跟任何值。 因为该函数返回一个字符串，我们在调用它时可直接将它作为一个字符串变量使用，例如将它直接放在Console.WriteLine() 命令里输出。同样也可以参与运算，例如 str = GetMyString() + &quot;abc&quot; ，总之可以像使用一个字符串变量一样使用它。 参数12345678910111213141516171819static string MaxValueStr(int[] intArray, string lang) &#123; int maxValue = intArray[0]; foreach (int intVal in intArray) &#123; if (intVal &gt; maxValue) &#123; maxValue = intVal; &#125; &#125; string resultStr = "The maximum value in myArray is " + maxValue; if (lang == "cn") &#123; resultStr = "该数组的最大值是：" + maxValue; &#125; return resultStr;&#125;static void Main(string[] args) &#123; int[] myArray = &#123;2,1,5,3,7,0,6&#125;; Console.WriteLine(MaxValueStr(myArray,"cn")); Console.ReadKey();&#125; 该函数找出传入数组的最大值，并根据传入的 lang 变量指定输出类型。 一个函数可以接收多个参数，而只能有一个返回值。如果参数大于一个，使用逗号隔开。 调用函数时传入的参数要求类型、个数、顺序都要匹配。 C#允许使用 params 关键字为函数指定一个特殊参数，这个参数只能放在参数列表的最后，称为参数数组，参数数组允许使用个数不定的参数调用函数。 参数数组可以简化代码，因为在调用函数的过程中，不必传入数组，只要传递几个相同类型的参数，这些参数会被放在该参数数组中。 123456//传入一个字符串，会返回字符串中的第一个单词string word = GetWord("This is a sentence");//传入一个字符串和一个整数，就可以根据该整数决定返回字符串中第几个单词string word = GetWord("This is a sentence",2);//传入一个字符串和两个整数，根据第一个整数决定返回第几个单词，根据第二个整数限制返回长度。string word = GetWord("This is a sentence",3,5); 例如我们希望有一个函数，可以完成以上多种功能。 123456789101112131415161718static string GetWord(string stentence, params int[] par) &#123; string resultStr; string[] words = stentence.Split(' '); switch (par.Length) &#123; case 1: resultStr = resultStr = words[par[0]];break; case 2: resultStr = words[par[0]].Substring(0, par[1]); break; default: resultStr = words[0]; break; &#125; return resultStr;&#125;static void Main(string[] args) &#123; string word0 = GetWord("This is a sentence"); string word1 = GetWord("This is a sentence", 2); string word2 = GetWord("This is a sentence", 3, 5); Console.WriteLine("&#123;0&#125;、&#123;1&#125;、&#123;2&#125;", word0, word1, word2); Console.ReadKey();&#125; 该程序仅为演示之用，实际编写中应加入边界的判断，防止因传入的参数过大或或小而导致的数组越界等情况。 另外，函数重载也可以实现这种功能，并且在 C# 4 之后引入了新的可选参数的形式。 上述介绍的参数都为值参数，值参数只是把变量的值传递给了函数，而非这个变量。 12345int myInt = 10;Console.WriteLine(myInt);ShowDouble(myInt); //该函数计算传入参数的二倍，并输出，函数不返回值Console.WriteLine(myInt);//依次输出 10 20 10 可以看到调用参数时只是将值 10 传递了过去，并没有改变 myInt 变量的值。如果想要改变 myInt 的值呢？ 12345int myInt = 10;Console.WriteLine(myInt);myInt = ShowDouble(myInt); //该函数计算传入参数的二倍，并输出。函数返回计算后的 int 类型值Console.WriteLine(myInt);//依次输出 10 20 20 但是如果我们需要改变多个传入变量的值呢？这是可以使用引用参数 12345678static void ShowDouble(ref int number) &#123; number *= 2; Console.WriteLine(number);&#125;//调用int myNumber = 10;ShowDouble(ref myNumber); 这里注意传入的参数需要保证是一个可变量，而不能是字面值、常量，也不能是未初始化的变量。 另外，C# 还提供了一个关键字 out 用来定义一个输出参数。它和 ref 定义的引用参数有相同的执行方式和使用方式。在函数执行完毕后，输出参数也将值返回给函数调用中使用的变量。但是它们还是有一些重要区别。 不能将未赋值的变量传递给 ref 参数，但可以传递给 out 参数。 即使将已经赋值的参数传递给 out 参数，在函数执行过程中该值也将丢失。 1234567891011static int MaxVal (int[] intArray, out int maxIndex) &#123; int maxVal; //寻找出最大值，并将值赋给 maxVal，将该值对应的下标赋给 maxIndex return maxVal;&#125;int[] intArray = &#123;1,5,8,6,3,7&#125;;int maxIndex;int maxVal = MaxVal(intArray, out maxIndex);Console.WriteLine("&#123;0&#125;, &#123;1&#125;",maxVal, maxIndex);//输出：8, 2 out 关键字和 ref 关键字的区别 如果方法的参数标记为 out ，那么调用者不希望在调用方法之前初始化对象，被调用的方法不能读取对象的值，而且被调用的方法必须在返回之前为对象赋值。如果方法的参数标记为 ref ,那么调用者必须在调用方法之前首先初始化参数的值，被调用的方法可以读取参数或为参数赋值。 #引自：victory的博客 变量的作用域12345678910static void Write() &#123; Console.WriteLine(myString);&#125;static void Main(string[] args) &#123; string myString = "in Main"; Write();&#125;//错误 当前上下文中不存在名称“myString” 报错的原因是变量是有作用域的，在作用域内，才是有效变量。 在 Write 函数中可以定义一个完全独立的 myString 变量，两个变量虽然名称相同，但是作用于不同，互不干扰。 123456789static void Write() &#123; string myString = "in Write"; Console.WriteLine(myString);&#125;static void Main(string[] args) &#123; string myString = "in Main"; Write();&#125; 像这样作用于一个函数的变量成为局部变量，还有一种全局变量，其作用域是多个函数。 1234567891011121314static string myString;static void Write() &#123; myString = "in Write"; Console.WriteLine(myString);// "in Write"&#125;static void Main(string[] args) &#123; myString = "in Main"; Console.WriteLine(myString);// "in Main" Write(); Console.WriteLine(myString);// "in Write" Console.ReadKey();&#125; 在函数之外定义了一个变量可供 Main 函数和 Write 共同使用。 全局变量也需要使用 static 或 const 关键字来定义。 12345678910111213static string myString;static void Write() &#123; myString = "in Write"; Console.WriteLine(myString);&#125;static void Main(string[] args) &#123; string myString = "in Main"; Console.WriteLine(myString); Write(); Console.WriteLine(Program.myString); Console.ReadKey();&#125; 如果局部变量和局部变量同名，那么在该局部变量的作用域内想使用全局变量需要使用 Program.myString 类名 + 变量名的形式。 那么我们可以通过这种定义全局变量的方式，使两个函数交换数据，为什么还要有函数参数和函数返回值呢？ 是否使用全局变量取决于函数的用途。使用全局变量的问题在于，它们通常不适合于“常规用途”的函数——这些函数能处理我们所提供的任意数据，而不仅限于处理特定全局变量中的数据。这些在后面的笔记中会详细解释。 其他结构中变量的作用域变量的作用域包含定义它们的代码块，和嵌套在其中的代码块，这也适用于其他的代码块，例如分支和循环。 12345for (int i = 0; i &lt; 10; i++) &#123; string text = "第" + i + "行"; Console.WriteLine(text);&#125;Console.WriteLine(text); text 变量定义在 for 循环中，它的作用域是 for 循环代码块，所以在 for 循环外使用 text 会产生错误。 123456string text;for (int i = 0; i &lt; 10; i++) &#123; text = "第" + i + "行"; Console.WriteLine(text);&#125;Console.WriteLine(text); 这段代码也会产生错误，原因是必须在使用变量前对其进行声明和初始化。但是由于 text 没有在循环外初始化，所以在循环块退出时 text 的初始化值就丢失了。 可以在定义 text 的时候对其初始化，例如：string text = &quot;&quot;; 。 这种情况的解释，涉及到分配给变量的内存空间。只声明一个简单变量类型，不会引起其他变化，而只有在给变量赋值之后，这个值才会被分配一块内存空间。如果这种分配内存空间的行为发生在循环之中，该值实际上定义为一个局部值，在循环外访问会超出作用域。 一般情况下，最好在声明和初始化所有变量后，再在代码块中使用他们。 一个例外是声明和初始化一个 for 循环的计数器，因为计数器仅为循环之用，所以很少在循环外使用它们。 参数和返回值与全局数据考虑下面两段代码 123456789101112static void showDouble(ref int val) &#123; val *= 2; Console.WriteLine(val);&#125;static void Main(string[] args) &#123; int val = 5; Console.WriteLine(val); showDouble(ref val); Console.WriteLine(val); Console.ReadKey();&#125; 1234567891011121314static int val;static void showDouble() &#123; val *= 2; Console.WriteLine(val);&#125;static void Main(string[] args) &#123; val = 5; Console.WriteLine(val); showDouble(); Console.WriteLine(val); Console.ReadKey();&#125; 两种方式结果相同。 使用全局变量的版本首先必须定义一个全局变量，若想要存储结果，必须把全局变量的值复制到其他变量中，因为全局变量的值可能会在其他的地方被改变，可能会导致预料不到的错误结果。这种方式也会使得代码本身更难以理解。 另一种使用引用参数的的版本更容易理解，函数需要哪些变量，计算后得到哪些变量，一眼便可看出。 应用程序变得复杂的时候，常常需要在多个文件下编写代码，这时全局变量就很难使用。 一般情况下，最好使用参数和返回值的形式。但少数情况下，使用全局变量更合适。 Main() 函数Main() 函数是程序的入口，执行这个函数就是执行应用程序，一旦 Main() 函数执行完毕，整个应用程序就结束了。 Main() 函数可以返回 void 或 int ，并有一个可选参数 string[] args ，这样可以组成一共 4 个版本。 返回值为 int 的 Main() 函数的返回值可以用于表示应用程序终止的方式，通常用作一种错误提示，一般情况下返回 0 代表应用程序正常退出。 可选参数 string[] args 可从应用程序外部接收数据，这些数据在运行应用程序时以命令行参数的形式指定。 例如在命令行输入 notepad 可以打开记事本，输入 notepad &quot;myfile.txt&quot; 可以打开 myfile.txt ，利用 string[] args 也可以编写类似的控制台应用程序。 右击项目，选择属性，点击调试选项卡，启动选项一栏中，在命令行参数设置中，键入希望添加的参数(可添加多个参数，用空格隔开，如果参数包含空格，则用双引号括起来)，可以方便的模拟这一行为。 这时我们就可以对 args 进行操作，例如循环输出等。 我们在命令行中，移动到该项目文件夹下的 DEBUG 目录内，使用项目名 + 参数的形式也可以完成操作。 结构函数定义一个结构，给结构中的元素赋值并输出 12345678910struct Address &#123; public string city, zipCode;&#125;static void Main(string[] args) &#123; Address addr; addr.city = "北京"; addr.zipCode = "100000"; Console.WriteLine("地址：&#123;0&#125;，邮编：&#123;1&#125;",addr.city,addr.zipCode); Console.ReadKey();&#125; 我们不仅可以在结构中添加数据元素，也可以在结构中添加函数。这样与此结构有关的常见任务，就可以被简化。 12345678910111213struct Address &#123; public string city, zipCode; public string OutPutAddress() &#123; "地址：&#123;0&#125;，邮编：&#123;1&#125;", , zipCode; &#125;&#125;static void Main(string[] args) &#123; Address addr; addr.city = "北京"; addr.zipCode = "100000"; addr.OutPutAddress(); Console.ReadKey();&#125; 函数并没有使用 static 修饰符，现在只需要知道该关键字不是结构函数所必需即可。 显然该函数在结构里更合适，也更易理解。这里 OutPutAddress 函数可以直接访问两个结构成员，因为在该结构中，它们可以被看作全局成员。 函数的重载假设我们需要计算 int 类型数组的和计算 double 类型数组的两个求数组最大值的函数，我们可以定义函数名分别为 intMaxVal 和 doubleMaxVal 的两个不同名称的函数。 现在有更合适的方式，就是函数的重载。 12345678910111213141516171819static int MaxVal(int[] arr) &#123; int maxVal = arr[0]; foreach (int val in arr) &#123; if (val &gt; maxVal) &#123; maxVal = val; &#125; &#125; return maxVal;&#125;static double MaxVal(double[] arr) &#123; double maxVal = arr[0]; foreach (double val in arr) &#123; if (val &gt; maxVal) &#123; maxVal = val; &#125; &#125; return maxVal;&#125; 虽然说两个函数的名称相同，但是函数签名并不相同。函数重载允许创建多个同名函数，但是需要函数签名不同。 函数的签名包含函数的名称及其参数，但是并不包含函数的返回类型。所以不能定义两个仅返回类型不同的函数，因为实际上它们拥有相同的签名。 在调用时，会根据传入的参数类型或参数个数来判断调用的函数，所以不必显式指定要使用哪个函数。 委托委托是一种存储函数引用的类型。 委托的生命类似与函数，使用 delegate 关键字。委托的声明指定了一个返回类型和一个参数列表。 定义委托后，就可以声明该委托类型类型的变量。接着把这个变量初始化为与委托具有相同返回值类型和参数列表的函数引用。之后，就可以使用委托变量调用这个函数，就像该变量是一个函数一样。 可以把委托变量作为参数传递给一个函数，函数就可以使用委托调用它引用的任何函数，而不用知道调用的哪个函数。 123456789101112131415161718192021222324252627delegate double ProcessDelegate(double param1, double param2);static double Multiply(double param1, double param2) &#123; return param1 * param2;&#125;static double Divide(double param1, double param2) &#123; return param1 / param2;&#125;static void Main(string[] args) &#123; ProcessDelegate process; Console.WriteLine("Enter 2 numbers separated with a comma:"); string input = Console.ReadLine(); int commaPos = input.IndexOf(','); double param1 = Convert.ToDouble(input.Substring(0, commaPos)); double param2 = Convert.ToDouble(input.Substring(commaPos + 1, input.Length - commaPos - 1)); Console.WriteLine("Enter M to multiply or D to divide"); input = Console.ReadLine(); if (input == "M") &#123; process = new ProcessDelegate(Multiply); &#125; else &#123; process = new ProcessDelegate(Divide); &#125; Console.WriteLine("Result: &#123;0&#125;",process(param1,param2)); Console.ReadKey();&#125; 首先定义了一个返回类型和参数与函数 Multiply 和 Divide 一样的委托。delegate double ProcessDelegate(double param1, double param2); Main() 函数中使用该委托类型声明了一个变量。ProcessDelegate process; 处理用户输入后，根据用户的选择(M 或 D)，初始化 process 变量process = new ProcessDelegate(Multiply);把一个函数引用赋给委托变量。使用 new 关键字并制定该委托类型创建一个新委托，提供一个引用所需函数参数，即是一个不带括号的函数名。简单的写法： process = Multiply; 编译器发现 process 变量必配两个函数签名。最后使用该委托调用所选函数。process(param1,param2); 也可以把委托变量传递给一个函数 123static void Fun (ProcessDelegate process) &#123; process(1.2, 2,3);&#125; 就像选择一个要使用的“插件”一样，通过把函数委托传递给函数，就可以控制函数的执行。同样的例如一个函数需对数组进行排序，但排序的规则有多种，这时就可以使用委托把排序算法函数委托传给该函数指定排序方式。 练习Q: 下面两个函数都存在错误，请指出这些错误。 12345678910static bool Write() &#123; Console.WriteLine("balabala...");&#125;static void MyFunction(string label, params int[] args, bool showLabel) &#123; if(showLabel) Console.WriteLine(label); foreach(int i in args) Console.WriteLine("&#123;0&#125;",i);&#125; A: Write 函数定义返回值类型为 bool ，实际却没有返回任何值。 MyFunction 函数英把可选参数 args 放在最后。 Q: 编写一个应用程序，该程序使用两个命令行参数，分别把值放在一个字符串和一个整形变量中，并显示这些值。 A:12345678static void Main(string[] args) &#123; if (args.Length &gt;= 2) &#123; int intVal = Convert.ToInt32(args[0]); string stringVal = args[1]; Console.WriteLine("intVal: &#123;0&#125;, stringVal: &#123;1&#125;", intVal, stringVal); Console.ReadKey(); &#125;&#125; Q: 创建一个委托，在请求用户输入时，使用它模拟 Console.ReadLine() 函数。 A: 12345678delegate string Read();static void Main(string[] args) &#123; Read read; read = Console.ReadLine; Console.WriteLine(read()); Console.ReadKey();&#125; Q: 修改下面的结构，使其包含一个返回订单总价格的函数 12345struct order &#123; public string itemName; public int unitCount; public double unitCost;&#125; A: 123456789struct order &#123; public string itemName; public int unitCount; public double unitCost; public double Total() &#123; return unitCost * unitCount; &#125;&#125; Q: 在 order 结构中添加另一个函数，使其返回如下所示的一个格式化字符串(一行文本，以合适的值替换尖括号括起来的斜体条目) Order Information: &#60;unit count&#62; &#60;item name&#62; items at \$&#60;unit cost&#62; each, total cost \$&#60;total cost&#62; A: 1234public string OrderString() &#123; return "Order Information: " + unitCount + " " + itemName + " items at $" + unitCost + " each, total cost $" + Total();&#125;]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第五章-变量的更多内容]]></title>
    <url>%2F2017%2F05%2F03%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8F%98%E9%87%8F%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[类型转换无论是什么类型，所有数据都是一系列的 0 和 1 ，但是不同的类型对相同的位有不同的解释。即使可以把一系列位从一种类型移动到另一种类型，结果也可能与期望不同。例如把 string 类型表示 123 的位，用 int 类型来解释，得到的结果不是数字 123 。要想正确的转换就需要对数据类型转换。 转换方式有两种 隐式转换 从类型 A 转换为类型 B ，可在所有情况下进行，规则简单，此时编译器就会自动转换。 显式转换 从类型 A 转换为类型 B ，只可在某些情况下进行，规则复杂，此时就需要额外的转换处理。 隐式转换简单的隐式转换示例 123456ushort a;char b = 'a';a = b;Console.WriteLine(a + ", " + b);Console.ReadKey();// 输出97, a 编译器自动把 char 类型转换为 ushort 类型。 从输出 97, a 这里可以看出，虽然两个变量存储的信息相同，但是不同的类型解释它们时，结果也是不同的。 这里注意 char 类型存储的是数值。 不是所有的类型都可以进行隐式转换，它是有条件的。但是我们并不需要记忆哪些类型转换可以隐式执行。 任何类型 A ，只要其中的取值范围完全包含在类型 B 中，就可以隐式转换为类型 B 。 例如 short 存储 [0, 32767] ，而 byte 存储 [0, 255] ，那么 byte 就可以安全的转换为 short，反之则不行。 如果 short 中存储的值在 [0, 255] 之间，也不可以将 short 隐式转换为 byte ， 而必须使用显式转换。 显式转换进行显式转换最简单的方法就是强制转换 12short a = 123;byte b = (byte)a; 这时就把 short 类型的 123 转换为了 byte 类型的 123 。 需要注意的是，彼此之间没有联系的类型不能进行强制转换。 如果此时 a = 266 的情况下进行强制转换，会发生什么呢？ 12short a = 266;byte b = (byte)a; 最后 a 为 256，b 为 10，而 byte 所能表示的最大值为 255。这并不是我们需要的结果。下面是这三个数的二进制表示 \begin{equation}\begin{split}&amp; 266 = 100001010 \\&amp; \ \ 10 = 000001010 \\&amp; 255 = 011111111 \\\end{split}\end{equation} 可以看到，10 相较于 266 丢失了最左边的位。这是错误的强制转换。 使用 checked 可以使编译器在转换期间检查是否丢失位。 12short a = 266;byte b = checked((byte)a); 此时如果再次编译程序则会报错 算术运算导致溢出 。与此相反的是 unchecked 。 使用 Convert 命令进行显式转换使用 Convert 进行显式转换的简单示例 12string a = "123";int b = Convert.ToInt32(a); Convert.ToInt32 命令把 字符串 &quot;123&quot; 转换为 数值 123。 此类转换要求字符串必须是数值的有效表达式，除简单的正数，还有正负(+、-)、科学计数法表示的数值。例如字符串 &quot;number&quot; 就不能转换为数值类型。 除此之外还有 Convert.ToBoolean 、Convert.ToString 等等。 转换的名称略不同于 C# 类型名称，例如要转换为 int 类型 需要使用 Convert.ToInt32 。这时因为这些命令来自 .NET Framework 的 System 名称空间，而不是 C# 本身。这样它们就可以兼容 .NET 中的其他语言。 shortVal * floatVal ，这里没有指定显式转换，所以如有可能，会执行隐式转换把 shortVal 转换为 float 类型。 也可以改变这种行为，比如 shortVal * (short)floatVal 这种数据类型转换语法与其他一元运算符优先级是一样的。 如果语句设计混合类型，就会根据运算符优先级进行转换。 1doubleResult = floatVal + (shortVal * floatVal); 先处理 shortVal * floatVal ， 将 shortVal 转换为 float 。 两个 float 类型相加并不需要转换。 最后将结果转换为 double 类型。 1shortVal1 * shortVal2 两个 short 类型数值相乘的结果实际上是 int 类型。因为结果很有可能大于 short 能存储的最大值。 复杂的变量类型除了简单的变量类型，C# 还提供了 3 个较为复杂的变量类型：枚举、结构和数组。 枚举除了 String 外，每种简单类型都有明确的取值范围。有时我们希望能自定义一种类型，这个类型只能存储我们指定的值。例如 Gender 类型，只能存储 male 和 female ，这时就可以使用枚举。 这里不仅仅是声明一个给定类型的变量，而是声明和描述一个自定义类型，再声明这个类型的变量。 定义枚举 12345enum Gender &#123; Male, Female&#125;// 最后一个值的逗号可忽略 声明这个枚举类型的变量，并赋值 1Gender gender = Gender.Male; 枚举类型可声明在类里面并且和函数同级，也可以声明在名称空间里面并且和类同级。推荐声明在名称空间内，这样所有在此名称空间内的类都可以使用此枚举。 枚举使用一个基本类型来存储，其中的每个值都存储为该基本类型的一个值，默认为 int ， 但也可以指定其他基本类型。 12345enum Gender : byte &#123; Male, Female&#125;// 最后一个值的逗号可忽略 除 char 之外的所有整数类型都可以被指定。 每个值都会根据定义的顺序(从 0 开始)，自动赋给对应的基本类型值。那么此示例中， Male 的值为 0 ，Female 的值为 1 。我们也可以自定义这个值。 1234enum Gender:byte &#123; Male = 10, Female = 11&#125; 还可以给多个枚举指定相同的值 123456enum Orientation:byte &#123; North = 10, South = North, East, West&#125; 此时 North 和 South 的值都为 10 。没有赋值的枚举会根据上一个明确声明的值来依次往下赋值，如这里 East 的值为 11，West 的值为 12。 1234567891011121314151617namespace ConsoleApplicationTest &#123; enum Orientation:byte &#123; North, South, East, West &#125; class Program &#123; static void Main(string[] args) &#123; Orientation myDirection = Orientation.East; byte directionByte = (byte) myDirection; string directionString = Convert.ToString(myDirection); Console.WriteLine("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", myDirection,directionByte,directionString); Console.ReadKey(); &#125; &#125;&#125; 虽然此枚举类型的基本类型是 byte，但仍然需要使用 (byte) 强制转换。 myDireciton = (direciton)myByte，可以将 byte 转换为此枚举类型。 要把枚举类型转换为 String 类型，不能使用 (string) ，因为这种转换也复杂一些，所以使用 Convert.ToString() ，或者使用变量本身的命令 myDirection.ToString() 。 也可以把 string 转换为枚举值，使用 Enum.Parse() 。 12string myStr = "North";myDirection = (Orientation)Enum.Parse(typeof(Orientation), myStr); typeof 可以得到操作数的类型。 如果传入的值不能映射为枚举值中的一个，例如传入 Center ，那么就会出现错误。并且值区分大小写。 枚举使得数据更加规范，因为只能使用枚举中给定的值。 使得代码更加清晰，因为可以使用描述性的名称表示整数值。 通过VS智能提示的帮助，使得代码更易输入。 结构结构就是由几个数据组成的数据结构，这些数据可能具有不同的类型。根据这个结构，可以定义自己想要的结构类型。 例如希望定义一种变量存储一个位置信息，包含到该位置的距离和方向 12Orientation myDirection;double myDistance; 可以定义两个变量来存储这些信息，但使用结构使用起来会更加清晰和简单 1234struct route &#123; public Orientation Direction; public double Distance;&#125; 通过该结构类型定义变量，同时使用该变量 123route myRoute;myRoute.Direction = Orientation.South;myRoute.Distance = 12.3; 下面的示例演示了结构和枚举的使用场景 12345678910111213141516171819202122232425namespace ConsoleApplicationTest &#123; enum Orientation : byte &#123; 东 = 1, 西 = 2, 南 = 3, 北 = 4 &#125; struct Route &#123; public Orientation Direction; public double Distance; &#125; class Program &#123; static void Main(string[] args) &#123; Route myRoute; Console.WriteLine("请输入方向（1.东 2.西 3.南 4.北）"); myRoute.Direction = (Orientation) Convert.ToInt32(Console.ReadLine()); Console.WriteLine("请输入距离"); myRoute.Distance = Convert.ToDouble(Console.ReadLine()); Console.WriteLine("方向：&#123;0&#125;，距离：&#123;1&#125;", myRoute.Direction, myRoute.Distance); Console.ReadKey(); &#125; &#125;&#125; 结构的声明位置和枚举相同。 数组数组可以方便的存放多个相同类型的值，并且很容易对这些值进行操作。 例如存储多个姓名 123string name1 = "name_a";string name2 = "name_b";string name3 = "name_c"; 可以定义多个字符串变量存储，但是这样批量操作起来很不方便，所以可以把多个相同变量合成一个变量，就是数组。 声明数组有两种方式 1int[] myIntArray = &#123;1, 2, 3, 4, 5&#125;; 第一种是在声明时就给出字面值指定数组中的值。第二种是先指定数组大小，再使用 new 关键字初始化数组元素 1int[] myIntArray = new int[5]; 这种方式初始化会把所有数组元素初始化为默认值，对于数值类型，默认值是 0 。这里 5 即数组长度，可以是一个变量。 也可以组合两种方式 1int[] myIntArray = new int[5] &#123;1, 2, 3, 4, 5&#125;; 这种方式有几点需要注意 数组长度必须与元素个数匹配。 因为需要匹配所以这里数组长度要么是字面值，要么是常量。 另外，数组也可以声明和初始化分开 12int[] myIntArray;myIntArray = new int[5]; 但不可以这样 12int[] myIntArray;myIntArray = &#123;1, 2, 3, 4, 5&#125;; 操作数组常常用到循环遍历数组内容 12345string[] nameArray = &#123; "小明", "小红", "小刚", "小军"&#125;;for (int i = 0; i &lt; nameArray.Length; i++) &#123; Console.WriteLine(nameArray[i]);&#125;Console.ReadKey(); 这里使用 nameArray.Length 来表示数组长度。 注意因为数组下标是从 0 开始的，即数组长度为 5 的数组，下标范围是 [0, 4] ，所以这里使用 &lt; 而不是 &lt;=。 如果使用 &lt;= 就是在尝试访问不存在的数组元素。这样很容易出问题，使用 foreach 循环访问数组元素，更方便也更安全。 12345string[] nameArray = &#123; "小明", "小红", "小刚", "小军"&#125;;foreach (string name in nameArray) &#123; Console.WriteLine(name);&#125;Console.ReadKey(); 使用 foreach 循环不必考虑数组的长度，相对安全，但是 foreach 循环只能对数组元素进行只读访问，也就是只能读取，不能修改。想修改数组内元素的值，还要用 for 循环。 假如我们希望存储姓名的同时存储该姓名对应的性别，这时候就可以使用多维数组 1string[,] person = new string[2,4]; 也可以使用字面值初始化 1string[,] person = &#123;&#123; "小明", "小红", "小刚", "小军"&#125;, &#123;"男", "女", "男", "男"&#125;&#125;; 要访问其中元素，只要给定其索引。如 person[0,1] 。 更多维的数组的数组初始化 1string[,,] arr = new string[2,3,3]; for 循环和 foreach 循环同样可以遍历数组元素。 需要注意的是，arr.Length 获取的是整个数组的长度，例如上述 person 数组的长度则为 8 ，这显然不合适遍历数组。所以这里需要多层 for 循环和另一个获取数组长度的命令 123456for (int i = 0; i &lt; person.GetLength(0); i++) &#123; for (int j = 0; j &lt; person.GetLength(1); j++) &#123; Console.WriteLine(person[i,j]); &#125;&#125;Console.ReadKey(); 多维数组可称为矩形数组，因为每一行的数组元素个数都相同。上面的例子也可以使用锯齿数组。 1234string[][] person = &#123; new[] &#123;"小明", "小红", "小刚", "小军"&#125;, new[] &#123;"男", "女", "男", "男"&#125;&#125;; 锯齿的含义是允许每行的数组长度不相同。 数组中可以包含数组，也可以有数组的数组的数组，等等。要注意的是，不论是多少数组嵌套，它们的基本类型都必须是相同的。 声明一个数组的数组1int[][] person; 但是初始化却不能采用之前的方式 123person = new string[2][4];//或person = &#123;&#123;"小明", "小红", "小刚", "小军"&#125;,&#123;"男", "女", "男", "男"&#125;&#125;; 可以先初始化外层数组，再依次初始化内层数组 1234567891011121314151617person = new string[2][];person[0] = new string[4];person[1] = new string[4];//或者另种改进形式person = new string[2][] &#123; new string[4]&#123;"小明", "小红", "小刚", "小军"&#125;, new string[4]&#123;"男", "女", "男", "男"&#125;&#125;;//另一种简化的形式string[][] person = &#123; new string[4]&#123;"小明", "小红", "小刚", "小军"&#125;, new string[4]&#123;"男", "女", "男", "男"&#125;&#125;; 使用 for 循环 和 foreach 循环遍历锯齿数组的示例 1234567891011for (int i = 0; i &lt; person.Length; i++) &#123; for (int j = 0; j &lt; person[i].Length; j++) &#123; Console.WriteLine(person[i][j]); &#125;&#125;foreach (string[] i in person) &#123; foreach (string j in i) &#123; Console.WriteLine(j); &#125;&#125; 因为锯齿数组是的元素还是数组，所以 for 循环 和 foreach 循环都需要嵌套才能得到希望的效果。 锯齿数组和矩形数组都能完成需求的情况下，使用矩形数组，只有锯齿数组才能完成需求的形况下，用锯齿数组。因为锯齿数组语法相对复杂。 字符串的处理string 类型可以看作是 char 变量的只读数组，例如 123string myStr = "A string";char myChar = myStr[2];//myChar 的值为 's' 获得一个可写的 char 数组 12string myStr = "A string";char[] myChars = myStr.ToCharArray(); myStr.Length 可以获得字符串的长度。 myStr.Trim() 可以删除字符串头尾的空格(因为用户可能无意间在头尾添加了无用的空格)。 也可以使用该命令删除指定的头尾字符串 12345char[] trimChars = &#123;'A',' '&#125;;string myStr = "A string";Console.WriteLine(myStr.Trim(trimChars));Console.ReadKey();// 输出字符串 "string" myStr.TrimStrat() 或 myStr.TrimEnd() 可以只删除前面或后面的空格，同样也可以指定 char 数组。 myStr.PadLeft(n) 或 myStr.PadRight(n) 可以在字符串左边或右边添加 n 个空格。 可以给定一个 char 变量指定添加的字符，例如 myStr.PadLeft(3,&#39;_&#39;) 向 myStr 左边添加 3 个下划线。 这里注意类似 Trim() 、ToLower() 、 ToUpper() 并未改变该字符串本身的值，而是产生一个新的字符串。可以与其他的字符串进行比较或者赋值给其他的变量。 12345678string myStr = "a,b,c,d";string[] myStrArray = myStr.Split(',');myStr = String.Join("-", myStrArray);foreach (string str in myStrArray) &#123; Console.WriteLine(str);&#125;Console.WriteLine(myStr);Console.ReadKey(); myStr.Split(&#39;,&#39;) 可以通过给出的字符分割字符串为字符数组。这里可以给出一个 char 数组，来指定多个分割字符。同样可以使用 String 类的 Join 方法将字符串数组使用指定的字符串拼接为新的字符串。 练习Q: 下面哪些转换不是隐式转换。 int -&gt; short short -&gt; int bool -&gt; string byte -&gt; float A: int -&gt; short 和 bool -&gt; string Q: 以 short 为基本类型编写一个 color 枚举，使其包含彩虹的颜色加上黑色和白色。这个枚举可以使用 byte 类型作为基本类型吗？ A: 123456789101112enum color : short &#123; Red, Orange, Yellow, Green, Cyan, Blue, Purple, White, Black&#125;//可以，byte 的最大值可以是 255 Q: 下面的代码可以成功编译吗？为什么？ 12string blab = new string[5]blab = 5th string. A: 不能，blab 的下标范围是 [0, 4] ，并且句尾没加分号，字符串值也应该用双引号括起来。 Q: 编写一个控制台应用程序，接受用户输入的一个字符串，将其中的字符串反向输出。 A: 12345string str = Convert.ToString(Console.ReadLine());for (int i = str.Length-1; i &gt;= 0; i--) &#123; Console.Write(str[i]);&#125;Console.ReadKey(); Q: 编写一个控制台应用程序，用 yes 替换字符串中所有的 no 。 A: 123string str = Convert.ToString(Console.ReadLine());Console.WriteLine(str.Replace("no","yes"));Console.ReadKey(); Q: 编写一个控制台应用程序，给字符串中的每个单词加上双引号。 A: 123456789101112string str = Convert.ToString(Console.ReadLine());str = str.Trim().PadLeft(1, '\"').PadRight(1, '\"').Replace(" ", "\" \"");Console.WriteLine(str);Console.ReadKey();//或string str = Convert.ToString(Console.ReadLine());foreach (string s in str.Trim().Split(' ')) &#123; Console.Write("\"" + s + "\"");&#125;Console.ReadKey();]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第四章-流程控制]]></title>
    <url>%2F2017%2F04%2F16%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[布尔逻辑分支和循环可以控制C#代码的执行顺序。分支根据结果有条件的执行，循环重复执行相同的语句，满足条件后停止。 条件使用布尔值来表示，例如 myVar &gt; 10 可以得到 true 或 false ，比较后得到的布尔便可以作为循环或者分支的条件。 布尔比较运算符有 ==、!=、&lt;、&gt;、&lt;= 和 &gt;= 几种。 数值类型的比较可以使用上述的所有运算符。字符串类型的比较仅可以使用 != 和 == 。布尔类型的比较可以使用 != 和 ==。 布尔类型的比较除了上述两种类型外还可以使用如下类型。 运算符 类别 示例 结果 ! 一元 var1 = !var2 var1的值是var2的相反的结果 (逻辑非) &amp; 二元 var1 = var2 &amp; var3 只有 var2 和 var3 同时为 true 时，var1才为 true ，否则为 false (逻辑与) &#124; 二元 var1 = var2 &#124; var3 var2 或 var3 其中之一为 true (或都是 true )，var1就是 true (逻辑或) ^ 二元 var1 = var2 ^ var3 var2 或 var3 有且仅有一个为 true，var1 才为 true ， 否则为 false (逻辑异或) 和 | 、 &amp; 类似的还有两种 || 、 &amp;&amp; ，两者使用方式和结果相同，但通常使用 || 、 &amp;&amp; ， 因为 || 、 &amp;&amp; 在检查左边的值以后，如果能判断出结果则跳过第二个。例如 true || true ， 左边为 true 的情况下，判断右边的值已经没有意义。因为使用这种方式效率更高。 使用 &amp;&amp; 、 || 的另一个好处就是避免程序出错。例如 var1 = (var2 != 0) &amp; (var3 / var 2 &gt; 2) ，此时如果 var2 值为 0 的话，程序在检测右边时就会出错，而使用 &amp;&amp; ，程序就会跳过右边。 || 和 &amp;&amp; 存在的意义在于按位运算符，它处理变量的位，而非变量的值。 布尔赋值运算符布尔赋值运算符 &amp;= 、 |= 和 ^= 。使用方法和 += 、 *= 等类似。 &amp;= 其实使用的是 &amp; 而不是 &amp;&amp; ，|= 、 ^= 与之类似。 按位运算符&amp; 、 | 和 ^ 不仅可以处理变量值，还可以处理变量中的位，这个时候称它为按位运算符。 使用按位运算符 &amp; 时，操作数1的每一位都与操作数2中相同位置的位进行比较，比较的方式如下表所示。 按位运算符 &amp; 操作数 1 中的位 操作数 2 中的位 &amp; 的结果位 1 1 1 1 0 0 0 1 0 0 0 0 1234int result, op1, op2;op1 = 4;op2 = 5;result = op1 &amp; op2; 首先按位运算中的位指的是二进制位，4 和 5 的 二进制位分别是 100 和 101。运算过程如下 \begin{equation}\begin{split}&amp;\ \ \ \ 1\ 0\ 0\qquad\ \ \ \ 4\\&amp;\&amp;\ 1\ 0\ 1\qquad\&amp;\ 5\\&amp;\underline{\hspace{3cm}}\\&amp;\ \ \ \ 1\ 0\ 0\qquad\ \ \ \ 4\\\end{split}\end{equation} 二进制 100 的十进制数是 4 ，所以 result 的值为 4 。 | 和 ^ 用法与 &amp; 类似。 还有一个一元的按位运算符 ~ ，它可以将变量中的位取反。 .NET 中使用补码存储整数，int类型是一个32位的数字。 5 的完整二进制为： 00000000000000000000000000000101 -5 的完整二进制为 111111111111111111111111111111011 按照补码系统，(-x)定义为(~x+1) 。例如，10 + (-5) 即是 10 + (~5+1) 123 000000000000000000000000000001010+ 111111111111111111111111111111011= 1000000000000000000000000000000101 截掉最左端的 1 ，即是 5 的二进制结果。 除了上述四种外，还有两种运算符 &gt;&gt; 和 &lt;&lt; 举例说明 12int var1, var2 = 10, var3 = 2;var1 = var2 &lt;&lt; var3; //var1 的值是40 10 的 二进制值是 1010 &lt;&lt; 代表把该值往左移动 2 位，即 101000 101000 的十进制值是 40 。 实际上每左移 &lt;&lt; 一次就是把该值乘以 2 。右移 &gt;&gt; 一次就是除以 2，而右移后的非整余数将丢失(取整)，例如 10 &gt;&gt; 2 的值是 2 。 &lt;&lt; 和 &gt;&gt; 也有类似 += 的赋值运算符 &lt;&lt;= 和 &gt;&gt;= 。 运算符的优先级增加了更多运算符后的优先级表如下所示 优先级 运算符 高 ++(前缀)、–(前缀)、+(一元)、-(一元) ↑ *、/、% ↑ +、- ↑ &lt;&lt;、&gt;&gt; ↑ &lt;、&gt;、&lt;=、&gt;= ↑ ==、!= ↑ &amp; ↑ ^ ↑ &#124; ↑ &amp;&amp; ↑ &#124;&#124; ↑ =、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、&#124;= 低 ++(后缀)，–(后缀) 同样的，使用()包裹仍然可以改变表达式中各运算的顺序。 goto 语句C#中可以给代码行加上标签，并使用 goto 语句直接跳转到该代码行。goto语句的优点是可以十分简单的控制代码的执行顺序，缺点是过多的使用将使代码变得难懂。使用方法如下 12345int myInt = 5;goto myLabel;myInt += 10;myLabel:Console.WriteLine(myInt); 最后输入 myInt 的值为 5 ，因为 goto 直接跳过了 myInt += 10; 这样做在编译时，会产生一个警告 监测到无法访问的代码。 应谨慎使用goto语句，原因是goto语句容易使代码变得难懂。 分支分支有三种类型 三元运算符 if 语句 switch 语句 三元运算符三元运算符的简单示例 1string str = myInt &lt; 10 ? "Less than 10" : "Greater than or equal to 10"; 此表达式的意思是，如果 myInt 小于 10 ，那么将 &quot;Less than 10&quot; 赋给 str ，反之则将 &quot;Greater than or equal to 10&quot; 赋给 str。 三元运算符使用于简单的判断赋值语句，不适用于复杂的判断。 if 语句三元运算符运算后会产生一个结果，例如上面的例子 myInt &lt; 10 ? &quot;Less than 10&quot; : &quot;Greater than or equal to 10&quot; 会产生一个字符串类型的值。而 if 语句没有结果，使用 if 语句是为了根据条件执行其他的语句。 简单的 if 语句示例 123456if (myInt &lt; 10)&#123; str = "Less than 10"; Console.WriteLine(str); Console.ReadKey();&#125; 使用布尔比较运算符的表达式 myInt &lt; 10，产生一个布尔类型的结果 true 或 false ，if 语句根据结果决定是否执行大括号内的语句。 if 语句可以跟 else 语句配合使用 12345678910if (myInt &lt; 10)&#123; str = "Less than 10";&#125;else&#123; str = "Greater than or equal to 10";&#125;Console.WriteLine(str);Console.ReadKey(); 如果 myInt &lt; 10 产生 true 执行 if 大括号的内容，否则执行 else 大括号的内容。 if 和 else 语句可以嵌套使用 1234567891011121314151617if (myInt &lt; 10)&#123; if(myInt &lt; 5) &#123; str = "Less than 5"; &#125; else &#123; str = "Less than 10"; &#125;&#125;else&#123; str = "Greater than or equal to 10";&#125;Console.WriteLine(str);Console.ReadKey(); if 或 else 只执行一条语句的情况下，可以省略大括号，但是不推荐这么做，因为省略大括号容易引起逻辑混淆。 12345if(myInt &lt; 10) if(myInt &lt; 5) str = "Less than 5";else str = "Greater than or equal to 10"; 此时我们希望当 myInt &lt; 10 为 false 时， str 的值为 &quot;Greater than or equal to 10&quot;，但是 else 只跟最近的 if 相匹配 ，所以当 myInt &lt; 10 为 true 并且 myInt &lt; 5 为 false 时，str 的值才为 &quot;Greater than or equal to 10&quot;，这显然不是我们的意思。 所以推荐的做法是即使 if 或 else 只执行一条语句，也要加 {} 。 1234567891011if (myInt &lt; 10)&#123; if (myInt &lt; 5) &#123; str = "Less than 5"; &#125;&#125;else&#123; str = "Greater than or equal to 10";&#125; 使用 if 语句根据 month 月份输出季度。 1234567891011121314151617181920if (month &gt;= 1 &amp;&amp; month &lt;=3)&#123; str = "第一季度";&#125;if (month &gt;= 4 &amp;&amp; month &lt;=6)&#123; str = "第二季度";&#125;if (month &gt;= 7 &amp;&amp; month &lt;=9)&#123; str = "第三季度";&#125;if (month &gt;= 9 &amp;&amp; month &lt;=12)&#123; str = "第四季度";&#125;if (month &gt; 12 || month &lt; 1)&#123; str = "月份有误";&#125; 虽然程序可以实现功能，但是如果 month 的值为 1 ，那么执行接下来的 if 语句是无意义的，这里就可以用到 else if 语句。 1234567891011121314151617181920if (month &gt;= 1 &amp;&amp; month &lt;= 3)&#123; str = "第一季度";&#125;else if (month &gt;= 4 &amp;&amp; month &lt;= 6)&#123; str = "第二季度";&#125;else if (month &gt;= 7 &amp;&amp; month &lt;= 9)&#123; str = "第三季度";&#125;else if (month &gt;= 9 &amp;&amp; month &lt;= 12)&#123; str = "第四季度";&#125;else&#123; str = "月份有误";&#125; 此时如果 month 的值为 1，那么在执行完 str = &quot;第一季度&quot;; 后遇到右大括号结尾 }，就会跳过接下来的个 else if 语句。 switch 语句简单的 swith 语句示例 123456789101112131415switch (myInt)&#123; case 0: str = "零"; break; case 1: str = "一"; break; case 2: str = "二"; break; default: str = "不属于零到二之间的数"; break;&#125; swith 适用于变量与多个零散的值进行比对，若相等，则执行该 case 语句块的内容，如果变量与每个 case 都不匹配，则执行 default 块中的内容。 在执行 case 语句块的过程中，遇到 break 语句则跳出整个 switch 语句。这里需要注意的是每个case 语句块的最后都应加上 break 语句，除非该 case 块没有内容，否则不加 break 是非法的。 那么 case 块中没有内容，有什么意义呢，我们可以使用 switch 语句完成上面根据 month 月份输出季度的功能，便可以明白。 1234567891011121314151617181920212223242526switch (month)&#123; case 1: case 2: case 3: str = "第一季度"; break; case 4: case 5: case 6: str = "第二季度"; break; case 7: case 8: case 9: str = "第三季度"; break; case 10: case 11: case 12: str = "第四季度"; break; default: str = "月份有误"; break;&#125; 如果 case 块最后没有 break 结束(仅在 case 块没有内容的情况下)，那么它会接下去执行下面的 case 块。 假设 month = 2，在程序进入到 case 2 语句块时，没有遇到 break，会继续往下执行，直到遇到 case 3 中的 break，才跳出 switch。 除了 break ，还可以使用 return 跳出，但是 return 是跳出整个函数，而非 switch 语句。 case 后跟的值必须是常数值，不能跟变量。一种方法是给出字面值 例如 1 、 &quot;abc&quot; 、 true 。另一个方法是提供常量。 常量有别于变量，一旦给出了常量的值，便无法再次更改，尝试更改常量的值是非法的。并且常量必须在声明的时候就给出值。 常量的声明方式如下 1const int myInt = 2; 以下两种赋值方式对常量来说是非法的 12345const int myInt;myInt = 2;const int myInt = 1;myInt = 2; 可以看出 switch 也可用于字符串的判断，但在判断用户输入的字符串时，往往不能确定用户输入字符串的大小写。这就使判断变得困难，例如姓名 Ben，用户可能有多种可能输入 ben 、BEN 等等。这时候可以使用字符串变量的两个函数 ToLower() 和 ToUpper()。 ToLower() 把字符串变成全小写，ToUpper() 把字符串变成全大写，示例如下 123string name = Console.ReadLine();Console.WriteLine("capitals: &#123;0&#125;, lower-case: &#123;1&#125;",name.ToUpper(), name.ToLower());Console.ReadKey(); 假设用户输入 Ben ，则程序输出 capitals: BEN, lower-case: ben 。 循环循环可以方便的执行重复的语句。重复语句的示例：假定存款金额为 1000 ，利率为 5% ，计算 10 年后该账户总金额若不使用循环，则需要每年做一次运算 123456double balance = 1000;double interestRate = 1.05;balance *= interestRate;balance *= interestRate;balance *= interestRate;//... 这里 balance *= interestRate; 即为重复的代码，循环可以简化这些操作。 do 循环对应上述例子的简单的 do 循环示例 123456int i = 0;do&#123; balance *= interestRate; i++;&#125; while (i &lt; 10); do 循环首先执行循环体内的代码，然后进行一个布尔测试，弱国条件满足，就再次执行，若不满足，则退出循环。 i 变量在这里可以成为计数器，它的值决定着是否执行循环。 这里注意 while 语句之后需要加上分号。 用户输入存款起始金额(balance)、利率(interestRate)、目标金额(targetBalance)，程序计算需要多少年才能达到目标金额。 123456789101112double balance = Convert.ToDouble(Console.ReadLine());double interestRate = 1 + Convert.ToDouble(Console.ReadLine()) / 100;double targetBalance = Convert.ToDouble(Console.ReadLine());int totalYears = 0;do&#123; balance *= interestRate; totalYears++;&#125; while (targetBalance &gt; balance);Console.WriteLine("&#123;0&#125;年", totalYears);Console.ReadKey(); 当我们输入的其实金额大于目标金额时(错误情况)，程序仍然会输出 1 ，这是因为 do 循环是先执行再判断，所以至少会执行一次。我们可以在循环外层加上 if 语句来判断这种情况，但更好的方式是使用 while 循环。 while 循环使用 while 循环对以上示例稍作修改 123456789101112double balance = Convert.ToDouble(Console.ReadLine());double interestRate = 1 + Convert.ToDouble(Console.ReadLine()) / 100;double targetBalance = Convert.ToDouble(Console.ReadLine());int totalYears = 0;while(targetBalance &gt; balance)&#123; balance *= interestRate; totalYears++;&#125;Console.WriteLine(totalYears == 0 ? "输入错误" : "&#123;0&#125;年", totalYears);Console.ReadKey(); while 循环在循环体执行之前，就对条件进行检查。避免了之前的错误情况发生。 用户输入的值是我们预料不到的，例如此示例中的错误输入，也可能是我们期望用户输入数字，却得到了字符串。这些是我们无法避免的，所以对用户输入的值进行校验非常重要。 for 循环for 循环可以完成所有 while 和 do 循环可以完成的工作。 for 循环语法 1234for(初始化;条件;计算)&#123; 循环体&#125; 使用 for 循环编写以上示例 12345int totalYears;for (totalYears = 0; targetBalance &gt; balance; totalYears++)&#123; balance *= interestRate;&#125; for 循环的 () 内做了三件事，初始化变量，判断是否满足条件，计数器自增。 需要注意的是，不只可以初始化计数器，也可以初始化其他的变量，甚至同时初始化多个变量，例如 totalYears = 0,myInt=0; 。 同时自增也可以多个变量自增，例如 totalYears++, myInt+=2 。 初始化变量部分，也可以同时完成对变量的定义，例如 for (int totalYears = 0; targetBalance &gt; balance; totalYears++) ，但是牵扯到变量作用域的问题，此时 totalYears 只能在 for 循环中起作用，不能在 for 循环之外使用 totalYears 变量。 循环的中断C# 提供了四条语句来中断循环，每种都有不同的作用 break ： 终止循环 continue ： 终止此次循环 goto ： 跳转到指定的标记位置 return ： 跳出循环以及包含该循环的函数 break、continue、return 的简单示例 12345678910for (int i = 0; i &lt; 10; i++)&#123; if (i == 6) &#123; break; // continue、return &#125; Console.WriteLine(i);&#125;Console.WriteLine("循环结束");Console.ReadKey(); break 输出 ： 1 2 3 4 5 循环结束continue 输出 ： 1 2 3 4 5 7 8 9 循环结束return 输出 ： 1 2 3 4 5 这里仍然不提倡使用 goto ， 另外需要注意的是使用 goto 跳出循环是合法的，但是使用 goto 进入循环是非法的。 无限循环当循环条件恒为真时，则为无限循环，在无限循环的循环体内，可根据中断循环的四条语句来终止循环。 无限循环在特定条件下是有意义的。 练习Q: 如果两个整数存储在变量 var1 和 var2 中，该进行什么样的布尔测试，看看其中的一个(但不是两个)是否大于10。 A: var1 &gt; 10 ^ var2 &gt; 10 Q: 编写一个应用程序，其中包含上一个练习的逻辑，要求用户输入两个数字，并且显示它们。但拒绝接受两个数字都大于 10 的情况，并要求用户重新输入。 A:123456789101112131415double var1;double var2;while (true)&#123; var1 = Convert.ToDouble(Console.ReadLine()); var2 = Convert.ToDouble(Console.ReadLine()); if(var1 &gt; 10 ^ var2 &gt; 10) &#123; Console.WriteLine("var1 : &#123;0&#125; , var2 : &#123;1&#125;", var1, var2); break; &#125; Console.WriteLine("input again");&#125;Console.ReadKey(); Q: 下面的代码存在什么错误 123456789int i;for (i = 1; i &lt;= 10; i++)&#123; if((i % 2) = 0) &#123; continue; &#125; Console.WriteLine(i);&#125; A: if((i % 2) = 0) 改为 if((i % 2) == 0) ， = 是赋值运算符，== 才是比较运算符。 table:nth-of-type(1) th:nth-of-type(1) { width: 10%; } table:nth-of-type(1) th:nth-of-type(2) { width: 12%; } table:nth-of-type(1) th:nth-of-type(3) { width: 18%; }]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第三章-变量和表达式]]></title>
    <url>%2F2017%2F03%2F29%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C# 的基本语法C# 语法由若干句语句构成，每条语句后应加入 ; 表示语句结束。 C# 是一种结构块语言，所有的语句都包含在 块 中，用 { 和 } 来表示一个块。 C# 区分大小写。 C# 代码中可以包含注释，注释供开发者阅读，在编辑器编译过程中会忽略注释。以下是 C# 中提供的三种注释。 12// 在需要注释的语句开头加入 // 符号// 这是一条单行注释 123/* 在需要注释的语句块的开始和结尾分别输入 '/*' 和 ' */' 这是一条多行注释 这是一条多行注释 */ 12/// 这是一条文档注释/// 此类注释除解释代码外还有另一个作用，可以通过配置，提取项目中的此类注释生成项目文档 C# 控制台应用程序的基本结构代码大纲可以展开和折叠代码，使代码更易于阅读。书写方式如下 1234#region 这段代码在控制台输出"Hello World"Console.WriteLine("Hello World");Console.ReadKey();#endregion 此时点击窗口右边的 + 号，就可以折叠代码，效果如下 变量变量的作用是用来存储数据。 数据可存储在变量之中，也可以从变量中取出数据，修改数据等。 变量是有类型的，不同类型的变量存储不同类型的数据，同时变量也有名称，使用 &lt;type&gt;&lt;name&gt; 的方式来声明一个变量。 因为变量的类型可以自己定义，所以变量类型是无限多的。有些简单的类型是已经预定义的。 简单类型多数简单类型是用来存储数值的，那么，为什么不使用一种类型而是多种类型来存储数值呢？原因是因为，不同的类型占用内存中不同的位数，位数越大，存储的数值范围越大，如果只用一种类型存储数值，那么它占用的位数必然很大，所以，存储小数值时，就会造成很多的浪费。 整数类型 类型 别名 允许的值 sbyte System.SByte [-128, 127] byte System.Byte [0, 255] short System.Int16 [-32768, 32767] ushort System.UInt16 [0, 65535] int System.Int32 [-2147483648, 2147483647] uint System.UInt32 [0, 4294967295] long System.Int64 [-9223372036854775808, 9223372036854775807] ulong System.UInt64 [0, 18446744073709551615] 上述类型都利用了 .NET Framework 中定义的标准类型，使用标准类型可以在各语言中交互。 一些类型前的 u 是 unsigned 的缩写，表示此类型中不能存储负数。 除了整数之外，还需要表示浮点数(小数)，有以下三种浮点数变量类型可供使用 类型 别名 m 的范围 e 的范围 近似最小值 近似最大值 float System.Single [0, $2^{24}$] [-149, 104] 1.5 × $10^{-45}$ 3.4 × $10^{38}$ double System.Double [0, $2^{53}$] [-1075, 970] 5.0 × $10^{-324}$ 1.7 × $10^{308}$ decimal System.Decimal [0, $2^{96}$] [-28, 0] 1.0 × $10^{-28}$ 7.9 × $10^{28}$ 其中，float 和 double 可以使用 +/-m×$2^{e}$ 的形式来存储浮点数，decimal 使用另外一种形式：+/-m×$10^{e}$。 除数值类型外，还有另外三种简单的类型 类型 别名 允许的值 char System.Char 一个 Unicode 字符，存储 [0, 65535] 之间的整数 bool System.Boolean 布尔值：true 或 false string System.String 一组字符 string 的字符数量没有上限，因为它使用可变大小的内存。 布尔类型常常用在分支当中，例如一个问题有多种选择。也常用于两种变量值之间的比较等。 简单类型的声明和使用的示例如下 123456int myInteger;string myString;myInteger = 17;myString = "\"myInteger\" is";Console.WriteLine("&#123;0&#125; &#123;1&#125;.", myString, myInteger);Console.ReadKey(); 第一、二行声明了两个变量，第三、四行对变量进行赋值，第五行使用变量输出了一些内容。 WriteLine() 可以用于输出内容，ReadLine() 可以用于读取用户的输入 变量的声明和赋值可以同时进行，例如： int myInteger = 17; 。 相同类型的变量可以同时声明和赋值，如： int a, b; 和 int a = 1, b = 2;，但这种情况 int a, b = 3 只是对变量 b 进行了赋值。 string类型存储的一组字符需要用 &quot; 包裹起来，如果字符本身含有 &quot; 则需要转义，即使用 \&quot; 来表示双引号，另外需要注意，不可在字符串(一组字符)中直接使用回车换行，若需要对字符串换行则使用 \n 进行转义。所有的转义序列都包含一个反斜杠，反斜杠本身也需要转义，即 \\ 。 Console.WriteLine(&quot;{0} {1}.&quot;, myString, myInteger); 中，使用 {n} 来表示输出的字符串中的变量，在字符串后跟变量名称，用逗号分隔，变量标记从 0 开始。 变量的命名变量的命名规则 第一个字母必须是字母、下划线或者@。 余下的字母可以是字母、数字、下划线。 不可使用关键字。 变量名称区分大小写。 建议的命名约定(camelCase 和 PascalCase) 约定 示例 作用于 camelCase myInteger、myString 用于变量 PascalCase StringToHtml、SqlHelper 用于类名、函数名、命名空间等 字面值前面提到了两各字面值 整数 (17) 和字符串 (“\”myInteger\” is”) 。一个字面值有多种类型，也有的字面值可以在后面添加后缀来制定想要的类型。 类型 类别 后缀 示例/允许的值 bool 布尔 无 true 或 false int, uint, long, ulong 整数 无 100 uint, ulong 整数 u 或 U 100U long, ulong 整数 l 或 L 100L ulong 整数 ul、uL、Ul、UL、lu、lU、Lu、LU 100UL float 实数 f 或 F 1.5F double 实数 无、d 或 D 1.5 decimal 实数 m 或 M 1.5M char 字符 无 ‘a’ 或转义序列 string 字符串 无 ‘a…a’ 或转义序列 转义序列 转义序列 产生的字符 字符的 Unicode 值 \’ 单引号 0x0027 \” 双引号 0x0022 \ 反斜杠 0x005C \0 空 0x0000 \a 警告(产生蜂鸣) 0x0007 \b 退格 0x0008 \f 换页 0x000C \n 换行 0x000A \r 回车 0x000D \t 水平制表符 0x0009 \v 垂直制表符 0x000B 上表中 “字符的 Unicode 值” 列是字符在 Unicode 字符集中的十六进制值。可以使用任何 Unicode 转义序列转义对应的字符。 123//下面两个字符串完全等价"I\'m a student.""I\u0027m a student." 如果不想使用转义序列来转义，那么可以在包含需要转义的字符的字符串前使用 @ 来避免使用转义序列。 1234//使用转义序列的字符串"C:\\WINDOWS\\FONTS\\Arial.ttf"//不使用转义序列的字符串@"C:\WINDOWS\FONTS\Arial.ttf" 表达式表达式用来处理变量。 操作数 (变量和字面值) 与运算符结合起来构成表达式。 运算符大致有三种 一元运算符，处理一个操作数。 二元运算符，处理两个操作数。 三元运算符，处理三个操作数。 数学运算符 运算符 类别 示例 结果 + 二元 a = b + c a 的值是 b 和 c 的和 - 二元 a = b - c a 的值是 b 减去 c 所得的值 * 二元 a = b * c a 的值是 b 和 c 的乘积 / 二元 a = b / c a 的值是 b 除以 c 所得的值 % 二元 a = b % c a 的值是 b 除以 c 余下的值 + 一元 a = +b a 的值等于 b 的值 - 一元 a = -b a 的值等于 b 的值的相反数 两个布尔类型的值相加 true + false 是错误的，两个 char 类型的值相加，因为 char 类型实际上存储的是数字，所以相加会得到一个数字 (int 类型) 。 二元运算符 + 也可以对字符串进行操作， &quot;abc&quot; + &quot;def&quot; 会得到一个新的字符串 &quot;abcdef&quot; ，但是其他的数学运算符不能对字符串进行操作。 还有另外两个一元运算符 运算符 类别 示例 结果 ++ 一元 a = ++b a 的值是 b+1，b 递增 1 – 一元 a = –b a 的值是 b-1，b 递减 1 ++ 一元 a = b++ a 的值是 b，b 递增 1 ++ 一元 a = b++ a 的值是 b，b 递增 1 ++ 在前，先自增，再运算。++在后，先运算，后自增。 123int a, b = 5, c = 6;a = b++ * --c;//这里 a 的值是 a++ 实际上是 a = a + 1 的简写形式。 ++ 和 -- 常用在循环中。 赋值运算符除等号 = 是一种赋值运算符以外，还有多种与数学运算符结合起来的赋值运算符。+= 、 -= 、 *= 、 /= 和 %= 。 ‘a += b’ 等同于 a = a + b ，其他运算符类似。 运算符优先级复杂的表达式中有多个运算符，那么就有先后计算的问题，下面是各运算符的优先级 优先级 运算符 高 ++(前缀)、–(前缀)、+(一元)、-(一元) ↑ *、/、% ↑ +、- ↑ =、+=、-=、*=、/=、%= 低 ++(后缀)，–(后缀) 名称空间名称空间是 .NET 中提供应用程序代码容器的方式，这样就可以唯一的标识代码及其内容。 在 A 名称空间中使用 A 名称空间中的项，只需要引用名称即可。而在 B 名称空间中使用 A 中的项，就必须写出该名称空间中的限定名称。限定名称包含它所有的分层信息。 12345678910111213namespace LevelOne&#123; using LevelTwo; // NameOne // NameThree namespace LevelTwo &#123; // NameTwo // NameThree &#125;&#125;// global namespace 名称空间可以嵌套。 在名称空间 LevelOne 中可直接使用使用 NameOne ，使用 NameTwo 需引用为 LevelTwo.NameTwo 。 在全局名称空间中使用 NameOne 需引用为 LevelOne.NameOne ，使用 NameTwo 需引用为 LevelOne.LevelTwo.NameTwo 。 名称由名称空间唯一定义，所以 NameThree 可分别在 LevelOne 和 LevelTwo 中定义。 在全局命名空间中可使用 LevelOne.NameThree 和 LevelOne.LevelTwo.NameThree 分别引用两个名称。 使用限定名称来引用不同名称空间中的项，十分繁琐。所以可使用 using 关键字避免这种情况。如上所示，在 LevelOne 中使用 using LevelTwo ，就可直接在 LevelOne 中使用名称来访问 NameTwo 。 但是对于两个名称空间都包含的 NameThree ，若直接使用名称则会产生错误，所以可以把 using LevelTwo; 改为 using LT = LevelTwo; ，这样就可以在 LevelOne 中使用 LT.NameThree 来引用 LevelTwo 中的 NameThree 。 using 语句应用到包含它的名称空间及其嵌套的名称空间中。 在创建的控制台程序中可以看到 using System; ，如果没有这个引用，那么 Console.WriteLine(&quot;balabala...&quot;); 就必须写成 System.Console.WriteLine(&quot;balabala...&quot;); 。 练习Q: 在下面的代码中，如何从名称空间 fabulous 的代码中引用名称 great ？ 1234567891011namespace fabulous&#123; // code in fabulous namespace namespace super &#123; namespace smashing &#123; // great name defined &#125; &#125;&#125; A: super.smashing.great 或者使用 using super.smashing; 就可以直接使用名称访问。 Q: 下面哪些变量名不合法？ myVariableIsGood 99Flake _floor time2GetJiggyWidIt wrox.com A: 第二个和最后一个。 Q: 字符串 “supercalifragilisticexpialidocious” 是不是太长了，不能放在 string 变量中？ A: 可以，因为 string 类型的字符数量没有上限，因为它使用可变大小的内存。 Q: 考虑运算符的优先级，列出下列表达式的计算步骤。 1resultVar += var1 * var2 + var3 % var4 / var5; A: 先算 * 、 % 和 / ，再算 + ， 最后算 += 。 Q: 编写一个控制台应用程序，要求用户输入 4 个 int 值，并显示他们的乘积。 A:123456789int num1, num2, num3, num4;Console.WriteLine("请依次输入 4 个整数，每次输入按回车键以确认");num1 = Convert.ToInt32(Console.ReadLine());num2 = Convert.ToInt32(Console.ReadLine());num3 = Convert.ToInt32(Console.ReadLine());num4 = Convert.ToInt32(Console.ReadLine());Console.WriteLine("&#123;0&#125;、&#123;1&#125;、&#123;2&#125; 和 &#123;3&#125; 的乘积是：&#123;4&#125;", num1, num2, num3, num4, num1*num2*num3*num4);Console.ReadKey();]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 创建登录用户及权限配置]]></title>
    <url>%2F2017%2F03%2F23%2FSQL-Server-%E5%88%9B%E5%BB%BA%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在服务器上的 SQL Server 创建登录名12-- 创建登录名create login TestUser with password='123456', default_database=TestDataBase 这一步骤创建了一个名称为 ‘TestUser’，密码为 ‘123456’，默认连接数据库为 ‘TestDataBase’ 的 登录名 。可以在当前连接中的安全性|登录名中看到刚刚创建的登录名。此时还不能用此登录名进行登陆，需要在刚刚填写的默认连接数据库下 default_database=TestDataBase ，即 TestDataBase， 新建一个数据库用户，并且把此数据库用户与刚刚创建的登录名建立关系(映射)。 创建数据库用户并与登录名建立关系12-- 创建数据库用户create user TestUser for login TestUser with default_schema=dbo 一般默认数据库用户名称和登录名名称相同。这里通过 default_schema=dbo 语句指定了该数据库用户的默认 schema 为 dbo ，这意味着当用户使用 select * from TestTable 语句时，实际上是 select * from dbo.TestTable 。此时可以用该登录名进行登录，但是无法访问相应的数据，这是因为与此映射的数据库用户还没有相应的权限。 登录名和数据库用户的关系 SQLSERVER把登录名与用户的关系称为映射。用登录名登录SQLSERVER后，在访问各个数据库时，SQLSERVER会自动查询此数据库中是否存在与此登录名关联的用户，若存在就使用此用户的权限访问此数据库，若不存在就是用guest用户访问此数据库。#参考自：百度知道 为数据库用户配置权限12-- 为数据库用户配置权限exec sp_addrolemember 'db_owner', 'TestUser' 数据库用户的各种权限和解释 权限名 作用 db_owner 固定数据库角色的成员可以执行数据库的所有配置和维护活动，还可以删除数据库 db_securityadmin 固定数据库角色的成员可以修改角色成员身份和管理权限。向此角色中添加主体可能会导致意外的权限升级 db_accessadmin 固定数据库角色的成员可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限 db_backupoperator 固定数据库角色的成员可以备份数据库 db_ddladmin 固定数据库角色的成员可以在数据库中运行任何数据定义语言 (DDL) 命令 db_datawriter 固定数据库角色的成员可以在所有用户表中添加、删除或更改数据 db_datareader 固定数据库角色的成员可以从所有用户表中读取所有数据 db_denydatawriter 固定数据库角色的成员不能添加、修改或删除数据库内用户表中的任何数据 db_denydatareader 固定数据库角色的成员不能读取数据库内用户表中的任何数据 #参考自：2cto 对登录名和数据库用户的更多操作 使登录名可以对多个数据库操作 123-- 只需要在该数据库下 (`use database_name`) 执行上述语句即可create user TestUser for login TestUser with default_schema=dboexec sp_addrolemember 'db_owner', 'TestUser' 禁用和启用登陆名 12alter login TestUser disablealter login TestUser enable 更改登陆名名称和密码 12alter login TestUser with name=TestUser2alter login TestUser with password='654321' 更改数据库用户名称和默认 schema 12alter user TestUser with name=TestUser2alter user TestUser with default_schema=sales 删除登录名和数据库用户 12drop login TestUserdrop login TestUser 文章参考自：http://www.cnblogs.com/xwdreamer table th:first-of-type { width: 20%; }]]></content>
      <tags>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第二章-编写 C# 程序]]></title>
    <url>%2F2017%2F03%2F16%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BC%96%E5%86%99-C-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Visual Studio 2012 开发环境 VS 2012 最常用的窗口 中文名 英文名 作用 解决方案资源管理器 Solution Explorer 显示解决方案包含的项目及文件 属性 Properties 显示选中文件或元素的详细信息，并可进行更改 错误列表 Error List 显示程序中的错误、警告等信息 控制台应用程序 创建并运行控制台应用程序 选择 文件 | 新建 | 项目 | 控制台应用程序 键入示例代码 12Console.WriteLine("hello Wrold!");Console.ReadKey(); 选择 调试 | 启动调试 或按 F5 即可看到如图所示的结果 桌面应用程序(WPF) 创建并运行桌面应用程序 选择 文件 | 新建 | 项目 | WPF 应用程序 打开 MainWindow.xaml 文件，可以分别看到 设计 和 代码 两个窗口 点击 工具箱 ，双击 Button 控件，可以看到 设计 窗口中添加了一个按钮 双击新加入的按钮，跳转到 MainWindow.xaml.cs 文件中，键入示例代码 1MessageBox.Show("Hello World"); 选择 调试 | 启动调试 或按 F5 即可看到如图所示的结果]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#入门经典]读书笔记-第一章-C#简介]]></title>
    <url>%2F2017%2F03%2F12%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-C-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[.net Framework 的含义 .net Framework跨平台.net Framework 不止可以在 windows 环境下运行，在 Linux 、 Os X 下。可以使用 .net Framework 的开源版本 Mono。此外，移动设 Iphone/Ipad (Mono Touch) 和 Android (Mono for Android) 也可以使用 .net Framework 。 .net Framework不止支持一种语言.net Framework 支持多种编程语言，例如 C++ 、 C# 、 VB 等，不同语言之间通过 .net Framework 可以互相通信。 .net Framework的内容.net Framework包含一个庞大的代码库，供客户语言（如C#）访问。库中定义一些数据类型，成为通用类型系统 (Common Type System, CTS) ，此外，还包含.net公共语言运行库 (Common Language Runime, CLR) ，它负责管理用 .net 库开发的应用程序的运行。 CIL 和 JIT在编译使用 .net 库的代码时，VS 会先把代码编译为通用中间语言 (Common Intermediate Language, CIL) 代码，这种代码通用于使用 .net 的所有语言。当应用程序开始执行时，Just-In-Time (JIT) 编译器会把 CIL 编译为专用于目标机器结构的本机代码。 托管代码除了将代码编译为 CIL ， 然后通过 JIT 编译为本机代码的任务外， CLR 还有内存管理、处理安全性、跨语言调试等任务，但是非托管应用程序，如C++编写的应用程序，不受 CLR 控制。 .net Framework的垃圾回收在 .net 以前，内存垃圾回收的操作一般由程序员编写代码来控制， .net 的垃圾回收功能，可使程序员不必须关心这项工作。 C# 的含义 C# 是类型安全语言C# 是一种类型安全语言，即定义了一个变量的类型，就不能再改变它的类型。 C# 和 .net Framework 的关系C# 是用于 .net 开发最好的语言，它可以使用 .net Framework 代码库提供的所有功能，且 .net Framework 新加入的功能都能在 C# 中得到体现。 C# 可以做的事情用 C# 可以编写 桌面应用程序 (winform、WPF(Windows Presentation Foundation)) 、 Windows Store 应用程序、 Web 应用程序、 WCF服务。 C# 应用程序访问数据库第3条所示的应用程序可以通过 .net Framework 中的 ADO.NET (Active Server Pages) 和 C# 中的 LINQ (Language Integrated Query) 来访问数据库。 Visual Studio Visual Studio通常使用 VS 来开发 C# 应用程序，它虽然不是必须的，但却是最方便的工具。除基本的代码编辑外， VS 还拥有调试、设计器、错误检查、快速创建项目等诸多实用功能。 解决方案解决方案可以包含多个项目，一个解决方案下的项目可以在硬盘的不同位置。也就是说通过解决方案，可以共享不同项目下的代码。]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>